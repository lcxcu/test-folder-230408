1. **模型的选择**
- 使用以下函数，设定所有潜在模型集
```R
# 潜在模型集
set_xx1 <- expand_weights_lags(weights = c("nealmon", "almonp","nbeta"), from = 0, to = c(83, 503), m = 84, start = list(nealmon = rep(0, 2), almonp = rep(0, 3) ,nbeta = rep(0,3)))
# list中为 各权重函数起始值 起始值的设定参考midar文档中示例
# set_xx1 生成一个包含元素权重、滞后时间和开始时间的列表。
```

 - 利用信息准则选择合适的最大滞后阶数与最佳函数约束
```R
# 模型估计和选择
eqs.ic <- midas_r_ic_table(yy1 ~ mls(yy1, 0 ,1) + mls(xx1, 1:83, 84), table = list(xx1 = set_xx1))

mod1 <- modsel(eqs.ic, IC = "AIC", type = "restricted")
mod2 <- modsel(eqs.ic, IC = "BIC", type = "restricted")
mod3 <- modsel(eqs.ic, IC = "AIC", type = "unrestricted")
mod4 <- modsel(eqs.ic, IC = "BIC", type = "unrestricted")

# 表中包含 给定滞后阶数结构 以及 无限制MIDAS回归模型的计算信息标准
```

在使用包中函数时暂时遇到以下报错(几次修改其中参数但仍存在以下问题，或许对模型的理解还不够透彻)
```R
# 模型估计时
Error in `[.default`(x, idx - h.x) : 
  only 0's may be mixed with negative subscripts
```

```R
# 模型选择时
Error in h(simpleError(msg, call)) : 
  在为'print'函数选择方法时评估'x'参数出了错: 在为'summary'函数选择方法时评估'object'参数出了错: attempt to select less than one element in get1index  
```

>另外通过对模型自由度的学习，考虑拟合的模型是否会因为拟合模型自由度过低影响数据预测，这也将进一步进行探究

>同时需要进一步研究以上用于选择模型的函数，确保模型选择是已知情况下恰当的

---
2. **数据的处理**
   使用python进行数据处理，经商讨后取每月20天的情况，以60的频率倍差进行数据处理成为新的可能，但还没有想好20天的数据提取的具体方式，这可能是个难题。
   但不排除20天可能会造成数据丢失过多的情况，我选择保留意见，可能会以20天/28天两边进行模型估计的情况
```python
import pandas as pd
import numpy as np
from pandas.tseries.offsets import CustomBusinessDay


data_all = pd.read_csv(r"G://data_all.csv" , dtype={'证券代码':str})
data_all['年-月'] = data_all['日期'].map(lambda x:x[0:-3])
data_all['日'] = data_all['日期'].map(lambda x:x.split('-')[2])

company = data_all.groupby(['证券代码','年-月'])
```
