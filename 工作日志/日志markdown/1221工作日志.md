1. **对所有（5206个）公司的数据进行数据预处理的python代码**（暂未完工，预计明天完成）

2. **对midasmlR包的学习**：
- 可使用自己的数据调用其中部分用于**拟合模型的函数**了，如`cv.sglfit`、`sglfit` ,`midas.ardl` , `ic.panel.sglfit`等函数都已成功调用, 但返回结果暂时未完全理解，后续将尝试在文章中阅读理解。（如cv.sglfit中返回lam.min，lam.1se）
- `thetafit `、`tscv.sglfit` 等函数似乎是因为k-folder中若k值设置不当报错，k值的设置暂未找到对应参数
- 如`cv.panel.sglfit`此类函数在使用时应将数据似乎应将转换为时间序列（似乎是因为对面板数据进行拟合），否则也会报错


>附： `1`中数据处理部分python代码
```python
import pandas as pd
import warnings
from datetime import datetime

# 开始数据导入
warnings.filterwarnings('ignore') # 忽略警告
xlsx_src = ["G:\\midasr_data\\source_data\\TRD_Dalyr"+str(i)+".xlsx" 
            for i in range(1,6)]
for i in range(0,5):
    data_stocks = pd.read_excel(xlsx_src[i],
                           header=0,skiprows=[0,2],usecols="A,B,C,D",
                           dtype={'证券代码':str})
data_stock = pd.concat(data_stocks)
data_stock  = data_stock.rename(columns={'交易日期':'日期'}) 
data_ea = pd.read_excel("G:\\midasr_data\\source_data\\IAR_Rept.xlsx",
                        header=0,skiprows=[0,2],usecols="A,D,E,F,G",
                        dtype={'证券代码':str})
data_ea1  = data_ea.rename(columns={'报告公布日期':'日期',
                                   '调整前每股收益':'调前财报(发布日期)',
                                   '调整后每股收益':'调后财报(发布日期)'}) 

data_ea2  = data_ea.rename(columns={'统计截止日期':'日期',
                                   '调整前每股收益':'调前财报(统计日期)',
                                   '调整后每股收益':'调后财报(统计日期)'})

code = list(set(data_stock['证券代码']))
date = list(pd.date_range('2017-11-29','2022-11-28').strftime('%Y-%m-%d'))
dict_date = { '证券代码': [c for c in code for d in date],
              '日期': date*len(code)}
date = pd.DataFrame(dict_date)        

data_src = pd.merge(date, data_stock,on = ['证券代码','日期'],how = 'left')
data_src1 = pd.merge(data_src, data_ea1[['证券代码','日期',
                                         '调前财报(发布日期)','调后财报(发布日期)']]
                     ,on = ['证券代码','日期'],how = 'left')
data_src2 = pd.merge(data_src, data_ea2[['证券代码','日期',
                                         '调前财报(统计日期)','调后财报(统计日期)']]
                     ,on = ['证券代码','日期'],how = 'left')

'''
# 暂时的数据存储
data_all1= data_src1.set_index(['证券代码'])
data_all2= data_src2.set_index(['证券代码'])
# 以财报发布日期整合5206个公司的财报与股票涨跌幅
data_all1.to_csv('G:\midasr_data\First_data\data_src1.csv') 
# 以财报统计日期整合5206个公司的财报与股票涨跌幅
data_all1.to_csv('G:\midasr_data\First_data\data_src2.csv') 
'''
# 数据导入完成

# 股票数据：日度数据，频率为28.
year_28 = [str(y) for y in range(2018,2023)]
month_28 = [str(m).rjust(2,'0') for m in range(1,13)] 
day_28 = [str(d).rjust(2,'0') for d in range(1,29)]
date_28 = []
for y in year_28:
    for m in month_28:
        for d in day_28:
            date_28.append(y+'-'+m+'-'+d)
date_28 = {'日期':date_28}
date_28 = pd.DataFrame(date_28)

def day28(c,data,date): # c = code; data = data_src2/data_src1; date = date_28
    df = data[data['证券代码'] == c ]
    # 用前一行和后一行分别数据填充NA
    df['涨跌幅'].fillna(method ='ffill', inplace = True)
    df['涨跌幅'].fillna(method ='bfill', inplace = True)
    daily_stock_df = pd.merge(date,df,on = ['日期'],how = 'left')
    daily_stock_df = daily_stock_df.dropna(subset=['证券代码']) 
    return daily_stock_df

stock_day28 = [day28(c, data_src2, date_28) for c in code]
data_stock_daliy28 = pd.concat(stock_day28, axis=0)
# 运行到这里记得保存一下数据
    


```