使用函数midas_r进行模型拟合
几个参数：
- MIDAS公式
- 低频序列使用`mls/fls/dls`函数
- 高频序列同上
- `start` 优化的初始值，使用OLS估计`lm`函数确定
我们的模型：
`eq_u <- lm(yy1 ~ mls(yy1, 0:1, m=1) + mls(xx1, 0:90, 90))`
示例：
`eq_u <- lm(y ~ mls(y, 0:1, m=1) + mls(x, k = 0:7, m = 4) + mls(z, k = 0:16, m = 12))`

---
数据缺失问题：
使用了R语言中的lm方法拟合，用predict函数预测缺失点的值
代码：
```R
time=company_1$日期
stock=company_1$股票涨跌幅
df <- data.frame(symbols=c("time","stock"),time,stock)
fit<-lm(stock~time,data=df)
newdf=data.frame(df$time[which(rowSums(is.na(df))==1)])
predict(fit,data=newdf)
```
---
代码：
``` R
library(midasr)  # l 加载midasr包
## 低频观测数
n <- 12
# 线性趋势和更高频率的解释变量
trend <- c(1:n)
company1_x <- subset(data,证券代码=='1',select=c('股票涨跌幅'))
x1g<-(company1_x$股票涨跌幅)*10
nx1 <- ts(c(rep(NA,59),x1g,rep(NA,33)), start = c(2017,274),frequency=365)  
xx1 <- window(nx1, start = c(2018,1), end = c(2020, 365)) 
company1_y <- subset(data,证券代码=='1',select=c('调前财报.统计日期.'))
company1_y <- na.omit(company1_y)# 去空值
y1g <- diff(log(company1_y$调前财报.统计日期.))
ny1 <-ts(c(y1g,NA,NA),frequency = 4,start = c(2015,12))
yy1 <- window(ny1, start = c(2018,1), end = c(2020, 4))
## 使用lm进行普通最小二乘估计
eq_u <- lm(yy1 ~ mls(yy1, 0:1, m=1) + mls(xx1, 0:90, 90))
```