1. 昨天模型预测效果不太好，搜索如何提升神经网络的模型预测性能
模型选择测试时用的仍是一支股票的数据
修改优化算法、L2惩罚(正则化项)参数、激活函数等，多次测试后模型还是存在过拟合，其中拟合较好的模型参数设置如下：
```python
fit1 = MLPRegressor(hidden_layer_sizes=(100,50), 
                    activation='relu',
                    solver='adam',alpha=0.01,
                    max_iter=200,early_stopping=True,validation_fraction=0.1)
```
模型结果**过拟合**
```python
fitting model right now
在训练集上的MSE =  0.013600173874120507
在测试集上的MSE =  0.041602473399879526
神经网络模型评价: -0.1834090281170111
```
![[Figure_1.png|500]]
优化过程中感觉MLPRegressor的限制较大，可选参数较少。

2. 尝试改用tensorflow进行深度学习拟合回归:
创建一个基于 TensorFlow 的序列模型，然后使用了三个密集层(Dense)来构建模型
第一层有32个节点, 激活函数是'relu',并且接受一个输入形状为 (31,) 的张量
第二层和第三层都是64个节点, 激活函数是'relu',没有输入形状
最后一层是一个输出节点，没有激活函数。然后编译模型，使用 **随机梯度下降** 优化器和 **均方误差**损失函数。
最后训练模型，训练100个epoch

仍选用一支股票的盈收变化值与0~30个滞后期的股票涨跌幅
结果如下：
```python
训练集上损失值: 0.017304006963968277
训练集上MSE: 0.08630163967609406
测试集上损失值: 0.0398595966398716
测试集上MSE: 0.10456321388483047
```

这个模型在训练集上表现良好，损失值和MSE都很小。
然而，在测试集上表现不如训练集，可能是过拟合的痕迹。
应该使用数据进行正则化或使用更多的测试数据来验证模型的泛化能力。
![[Figure_1 1.png|500]]
![[test 1.png]]

```python
import tensorflow as tf
import numpy as np
import pandas as pd
data = pd.read_csv('G:\\Data\\midar_data\\src_data\\Result_0_30.csv')
data = data.dropna()

data_test = data[data['Stkcd']== 900917]
data_test['changerate'] = data_test['Erana'].diff() # 取盈余差分
data_test = data_test.dropna(axis=0, how='any') # 去除含NA的行
data_test = data_test[data_test.changerate != 0] # 去除changerate为0的行
y,x = data_test['changerate'],data_test.iloc[:,6:-1]   

# 按二八原则划分训练集和测试集
from sklearn.model_selection import train_test_split
np.random.seed(2023)
x_train, x_test, y_train, y_test = train_test_split(x,y,test_size = 0.2)
# 创建模型
model = tf.keras.Sequential()
from tensorflow.keras import layers
input_shape = (31,)
model.add(layers.Dense(32, activation='relu', input_shape=input_shape))
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(1))
# 编译模型
model.compile(optimizer='sgd', loss='mean_squared_error')
# 训练模型
model.fit(x_train, y_train, epochs=100)
pred_test = model.predict(x_test)
print("预测值:",  pred_test)
# 评估模型
y_train = np.array(y_train).reshape(len(y_train),1)
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mean_absolute_error'])
score = model.evaluate(x_train, y_train, verbose=0)
print("训练集上损失值:", score[0])
print("训练集上MSE:", score[1])
y_test = np.array(y_test).reshape(len(y_test),1)
score = model.evaluate(x_test, y_test, verbose=0)
print("测试集上损失值:", score[0])
print("测试集上MSE:", score[1])
```
