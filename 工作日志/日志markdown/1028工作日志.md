>今天主要进行的是**第三步**，第一、二步为将最近的代码工作串起来而写上

#### 1. 获取要处理的基本数据
执行程序名为`公司全称和公司缩写建立上下游关系.py`程序，
```import xlrd
import xlwt

# global firm names 和 us names 的 Global Company Key 和 Company Name 提取
global_workbk = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'+
                                  '\Database Table\global firm names.xlsx')
```
上面最后一行在读取 *global firm names.xlsx* 文件，使用时请改成**对应文件保存的位置**
```
global_worksh = global_workbk.sheet_by_name('0x77igavdumz8vul')
global_cpnames = global_worksh.col_values(colx = 7, start_rowx = 1)
global_cpkey = global_worksh.col_values(colx = 0, start_rowx = 1)
# 组成列表
global_namekey = list(zip(global_cpnames, global_cpkey))


us_workbk = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'
                              +'\Database Table\\us names.xlsx')
```
上面最后一行在读取 *us_ names.xlsx* 文件，使用时请**改成对应文件保存的位置**
```
us_worksh = us_workbk .sheet_by_name('76aqys7wh9axjpme')
us_cpnames = us_worksh.col_values(colx = 9, start_rowx = 1)
us_cpkey = us_worksh.col_values(colx = 0, start_rowx = 1)
# 组成列表
us_namekey = list(zip(us_cpnames,us_cpkey))
# 将customer表中的Customer Name列和Global Company Key 提取出
customer_workbk = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'+
                                     '\Database Table\customer.xlsx') 
```
上面最后一行在读取*customer.xlsx*文件位置，使用时请**改成对应文件保存的位置**
```
customer_worksh = customer_workbk.sheet_by_name('vozkv0ioajsw5wov')
customer_downstream = customer_worksh.col_values(colx = 2, start_rowx = 1)
customer_upkey = customer_worksh.col_values(colx = 0, start_rowx = 1)
# 组成列表
customer_up_down = list(zip(customer_upkey,customer_downstream))


# global firm names 和 us names 的Global Company Key 和 Company Name列表合并后去重
Allnamekey_lst = list(set( global_namekey+us_namekey))
#对customer_up_down列表也去重
customer_up_down = list(set(customer_up_down))
#按照Global Company Key进行排序
Allnamekey_lst.sort(key=lambda x:x[1])

# 将Global Company Key 和 Company Name 写入Allcompany表中
Allcompany = xlwt.Workbook()
Allcompany_sheet = Allcompany.add_sheet('sheet1')
name_list = ['Global Company Key','Company Name(upstream)','Downstream']
for i in name_list:
    Allcompany_sheet.write(0, name_list.index(i), i)

for namekey in Allnamekey_lst:
    Allcompany_sheet.write(Allnamekey_lst.index(namekey)+1,0,namekey[1])
    Allcompany_sheet.write(Allnamekey_lst.index(namekey)+1,1,namekey[0])
    
cust_num = [[i[1],0] for i in Allnamekey_lst]
#比较 upstream key(customer_up_down[i][0])和global company key(Allnamekey_lst[j][1])
for upkey_down in customer_up_down:
    for name_key in Allnamekey_lst:
        if upkey_down[0] == name_key[1]:
            Allcompany_sheet.write(Allnamekey_lst.index(name_key)+1
                                   ,2+cust_num[Allnamekey_lst.index(name_key)][1]
                                   ,upkey_down[1])
            cust_num[Allnamekey_lst.index(name_key)][1] += 1

# 保存文件
Allcompany.save('Allcompany.xlsx')
```
最后一行是保存*Allcompany.xlsx*文件的位置，可以不修改，默认保存在同py文件的文件夹下。

>Allcomany.xlsx文件里保存的有
  >第一列：Global Company Key 每个公司特有的一串数字
  >第二列：Company Name(upstream) 上游公司的全称
  >第三列以后：Downstream 与上有公司对应的，下游公司的缩写

>对数据进行了哪些处理：
>1. 里面上游公司的名称没有重复，都只出现一次
>2. 数据都是按照 Global Company Key 公司特有的关键字 从小到大排列

在我的电脑上代码执行大约需要25min
**执行后结果如下**：![[Pasted image 20221026153356.png]]

----
### 2. **对获取到的全称进行预处理**:
执行`公司全名的预处理.py`文件
从第一步中得到的Allcompany.xlsx中获取所有公司的Allcpkey(每个公司特有的一串数字）和Allcpname（公司全名）

注 : 第一行路径对应上面**第一部分代码中生成的Allcompany文件位置**
```
    
'''
从Allcompany中读取数据
 Allcpkey 用于保存公司缩写
 Allcpname用于保存公司全称 
 '''
Allcompany = xlrd.open_workbook(r'C:\Users\jc\Documents\大学'
                                +'\\0大三其他\\_金融数据挖掘科研课题'
                                +'\Allcompany.xlsx') 
Allcompany_sheet = Allcompany.sheet_by_name('sheet1')
Allcpkey = Allcompany_sheet.col_values(colx = 0, start_rowx = 1)
Allcpname = Allcompany_sheet.col_values(colx = 1, start_rowx = 1)
```


创建表Allcpdata,全称All Company Data表格，用于存储全称公司的：
>Global Company key, Full name, company type , country ，Cleande Full Name

其中 Cleande Full Name 表示去除了公司后缀的全称,用于后续与缩写的匹配 
country 用于存储公司可能所在的国家，有些无法识别出就空着

1. 创建All company match表格的表头
```
# 1.创建All Company Data表格，写好表头
Allcpdata_wb = xlwt.Workbook()
Allcpdata = Allcpdata_wb.add_sheet('sheet1')
name_list = ['Global Company key', 'Full name',  'company type' , 'country' ,'Cleaned Full Name']

for i in range(len(name_list)):
    Allcpdata.write(0, i , name_list[i])
```

2. 将Global Company key写进表中 第i+1行,第0列
```
for i in range(len(Allcpkey)):
    Allcpdata.write(i+1, 0 , Allcpkey[i])
```

3. 将Full name写进表中 第i+1行，第1列
```
for i in range(len(Allcpname)):
    Allcpdata.write(i+1, 1, Allcpname[i])
```
4. 将company type写入表中 第i+1行，第2列, 用 cleanco中typesources()和match()判断
```
for i in range(len(Allcpname)):
    Allcpdata.write(i+1, 2, matches(Allcpname[i], typesources()))
```
5. 将country 写入表中 第i+1行，第3列, 用cleanco中match()和countrysources()判断
```
for i in range(len(Allcpname)):
    Allcpdata.write(i+1, 3,matches(Allcpname[i],countrysources()))
```
6. 清理不必要的后缀与符号，并转换为小写字符 写入表中，第i+1行，第4列，用clean_name()判断。
```
for i in range(len(Allcpname)):
    Allcpdata.write(i+1, 4, (clean_name(Allcpname[i]).lower()))
```
关于 clean_name 方法解释如下：
1. 用cleanco中的basename删除后缀
    (A.S./ N.V./  SA/SG S.A.与这一步共同进行单独处理)
    (-CL A,-CL B,-CL C ,-CL I)单独处理
2. 删除未识别出的后缀
    ETF ，A/S  ，-ADR ，INC-OLD,group，
3.  再用cleanno中的basename删除一次，确保删除干净了

以下是clean_name方法，**基本能将company name中所有后缀与国家名都删除，并不丢失此外的其他字符。**
```
def clean_name(string):
    '''
    1. 用cleanco中的basename删除后缀
    (A.S./ N.V./  SA/SG S.A.与这一步共同进行单独处理)
    (-CL A,-CL B,-CL C ,-CL I)单独处理
    2.删除未识别出的后缀
    ETF ，A/S  ，-ADR ，INC-OLD,group，
    3. 再用cleanno中的basename删除一次，确保删除干净了
    ---
    return 公司清理后缀后的名称
    '''
    #1.
    # 截取最后5个判断是否有-CL_?类后缀，如果有则删去
    str_suffix0 = string[:len(string)-6:-1][::-1].replace(' ','')
    if '-CL' in str_suffix0:
        string = string[:string.find('-')]
    string = re.sub(r'[\W]',' ',string) # 首先删去字符影响，替换为空格
    string = cleanco.basename(string) # 用cleanco里自带的basename做第一次后缀清除
    clean_suffix0 = ['A/S','N.V.','SA/AG','S.A.']
    for cs in clean_suffix0:
        if cs in string:
            string = string[:string.rfind(cs[0])]
    #2.
    # 进行第二次后缀清理
    # 截取最后 ５个字符,并删除其中的空格 为什么是５个（因为根据观察，自动清除的后缀里，最长的是GROUP，所以取最后5个判断不会有漏）
    str_suffix = string[:len(string)-6:-1][::-1].replace(' ','')
    clean_suffix = ['CO','ETF','AS','ADR','SA','AG','OLD','GROUP'] # 判断是否包含这些后缀
    for cs in clean_suffix:
        if cs in str_suffix:
            string = string[:string.rfind(cs[0])]
    #3.
    #用basename进行第三次后缀处理
    string = cleanco.basename(string)
    return string
```

最后进行文件的保存：
```
Allcpdata_wb.save('All Company Data.xlsx')
```

数据处理结果如下：
![[Pasted image 20221028004317.png]]

#### 3.对获取到的缩写进行预处理
    执行`公司缩写的预处理.py`文件，基本步骤与第二步差不多
第一步， 从` customer.xlsx`中读取数据， company_abbr 用于保存公司缩写, company_upkey用于保存用于识别缩写对应的上游公司的特殊数字串 
 ```
customer_wb = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'+
                                     '\Database Table\customer.xlsx') 
customer = customer_wb.sheet_by_name('vozkv0ioajsw5wov')
company_abbr = customer.col_values(colx = 2, start_rowx = 1)
company_upkey = customer.col_values(colx = 0, start_rowx = 1)
# 组成列表
abbr_upkey_zip = list(set((zip(company_abbr,company_upkey))))
# 第i组： abbr_upkey_zip[i][0]公司缩写 abbr_upkey_zip[i][1]上游公司key
```

第二步，创建表Abbrdata,全称Abbreviation Data表格，用于存储缩写公司的：
Global Company key(upstream), Abbreviation, company type , country ，Cleaned Abbreviation
其中 Cleaned Abbreviation 表示去除了公司后缀的缩写,用于与公司全称的匹配 
country 用于存储公司可能所在的国家，有些无法识别出就空着。
1.创建Abbreviation Data表格，写好表头
```
Abbrdata_wb = xlwt.Workbook()
Abbrdata = Abbrdata_wb.add_sheet('sheet1')
name_list = ['Global Company key(upstream)', 'Abbreviation', 
              'company type' , 'country' ,'Cleaned Abbreviation']

for i in range(len(name_list)):
    Abbrdata.write(0, i , name_list[i])

```
2.将Global Company key(upstream)写进表中 第i+1行,第0列
```
for i in range(len(abbr_upkey_zip)):
    Abbrdata.write(i+1, 0 , abbr_upkey_zip[i][1])
```
 3.将Abbreviation写进表中 第i+1行，第1列
```
for i in range(len(abbr_upkey_zip)):
    Abbrdata.write(i+1, 1, abbr_upkey_zip[i][0])
```
 4.将company type写入表中 第i+1行，第2列，用 cleanco中typesources()和match()判断
```
for i in range(len(abbr_upkey_zip)):
    Abbrdata.write(i+1, 2, matches(abbr_upkey_zip[i][0], typesources()))
```
 5.将country 写入表中 第i+1行，第3列, 用cleanco中match()和countrysources()判断
```
for i in range(len(abbr_upkey_zip)):
    Abbrdata.write(i+1, 3,matches(abbr_upkey_zip[i][0],countrysources()))
```
6.清理不必要的后缀与符号，并转换为小写字符 写入表中，第i+1行，第4列，用cleanco.clean_name()判断
```
for i in range(len(abbr_upkey_zip)):
    Abbrdata.write(i+1, 4, (clean_name(abbr_upkey_zip[i][0]).lower()))

Abbrdata_wb.save('Abbreviation Data.xlsx')
```
最后保存数据在`Abbreviation`

---
第三步中对缩写的数据清洗有点瓶颈
面临问题：
1. 多个缩写配对同一个公司全称
2. 多个公司全称匹配一个缩写
以上进一步判断是否该通过人工进行，讨论之后再做决定

其他工作：
> 1.  相关的 Allcompany.xlsx ， All Company Data.xlsx ，Abbreviation Data.xlsx 文件已上传至OneDrive--Liuchenxin文件夹
 >2.  阅读《Using Natural Language Processing for Supply Chain Mapping》论文，阅读部分论文的笔记  `(NOTE) Schöpper, H., Kersten, W., Using Natural Language Processing for Supply Chain Mapping` 已上传至OneDrive---Liuchenxin文件夹