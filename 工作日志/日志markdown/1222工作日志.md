1. 对5206家公司数据进行处理，将高频数据频率统一
- 日度数据取前28天（后续可能会采取22天，暂时没想到合适的办法书写代码）
- 周度数据取每月前12周，若该季度周数据数目小于12周，则用最后一周（11周数据）将该季度数据填充为12周
（后附代码）

2. 细读论文《Automated Earnings Forecasts : Beat Analysts or Combine and Conquer》Section 1 和 Section 2:
- 论文研究内容主要包括
	- 实现**开发自动化营收预测的应用**
	 - **使用midas-combination模型（从多个预测变量的组合中选取出最佳的预测，以提高预测准确性）预测公司层面的营收**
	 - 使用模型与分析师相结合比只通过分析师预测更有效
另外该论文研究结果初步支持了**在高频基础上自动化预测公司层面盈利或其他会计业绩指标的可能性** 
对团队研究而言，该论文可用于支持**高频变量预测财报营收**的有效性

> `1`中数据处理完整代码
```R
# -*- coding: utf-8 -*-
"""
Created on Wed Dec 21 20:25:06 2022

@author: jc
"""

import pandas as pd
import numpy as np
import warnings
from datetime import datetime, timedelta

# 开始数据导入
warnings.filterwarnings('ignore') # 忽略警告
xlsx_src = ["G:\\midasr_data\\source_data\\TRD_Dalyr"+str(i)+".xlsx" 
            for i in range(1,6)]
data_stocks = [pd.DataFrame() for i in range(0,5)]
for i in range(0,5):
    data_stocks[i] = pd.read_excel(xlsx_src[i],
                           header=0,skiprows=[0,2],usecols="A,B,C,D",
                           dtype={'证券代码':str})
data_stocks = pd.concat(data_stocks)
data_stocks  = data_stocks.rename(columns={'交易日期':'日期'}) 
data_ea = pd.read_excel("G:\\midasr_data\\source_data\\IAR_Rept.xlsx",
                        header=0,skiprows=[0,2],usecols="A,D,E,F,G",
                        dtype={'证券代码':str})
data_ea1  = data_ea.rename(columns={'报告公布日期':'日期',
                                   '调整前每股收益':'调前财报(发布日期)',
                                   '调整后每股收益':'调后财报(发布日期)'}) 
data_ea2  = data_ea.rename(columns={'统计截止日期':'日期',
                                   '调整前每股收益':'调前财报(统计日期)',
                                   '调整后每股收益':'调后财报(统计日期)'})

code = list(set(data_stocks['证券代码']))
date = list(pd.date_range('2018-01-01','2022-11-28').strftime('%Y-%m-%d'))
dict_date = { '证券代码': [c for c in code for d in date],
              '日期': date*len(code)}
date = pd.DataFrame(dict_date)        
data_src = pd.merge(date, data_stocks,on = ['证券代码','日期'],how = 'left')
data_src1 = pd.merge(data_src, data_ea1[['证券代码','日期',
                                         '调前财报(发布日期)','调后财报(发布日期)']]
                     ,on = ['证券代码','日期'],how = 'left')
data_src2 = pd.merge(data_src, data_ea2[['证券代码','日期',
                                         '调前财报(统计日期)','调后财报(统计日期)']]
                     ,on = ['证券代码','日期'],how = 'left')

'''
# 暂时的数据存储
data_all1= data_src1
data_all2= data_src2
# 以财报发布日期整合5206个公司的财报与股票涨跌幅
data_all1.to_csv('G:\midasr_data\First_data\data_src1.csv') 
# 以财报统计日期整合5206个公司的财报与股票涨跌幅
data_all2.to_csv('G:\midasr_data\First_data\data_src2.csv') 
'''
# 数据导入完成

# 股票数据：日度数据，频率倍差为84.
year_28 = [str(y) for y in range(2018,2023)]
month_28 = [str(m).rjust(2,'0') for m in range(1,13)] 
day_28 = [str(d).rjust(2,'0') for d in range(1,29)]
date_28 = []
for y in year_28:
    for m in month_28:
        for d in day_28:
            date_28.append(y+'-'+m+'-'+d)
date_28 = {'日期':date_28}
date_28 = pd.DataFrame(date_28)

def day28(c,data,date): # c = code; data = data_src2/data_src1; date = date_28
    df = data[data['证券代码'] == c ]
    # 用前一行和后一行分别数据填充NA
    df['涨跌幅'].fillna(method ='ffill', inplace = True)
    df['涨跌幅'].fillna(method ='bfill', inplace = True)
    daily_stock_df = pd.merge(date,df,on = ['日期'],how = 'left')
    daily_stock_df = daily_stock_df.dropna(subset=['证券代码']) 
    return daily_stock_df

stock_day28_1 = [day28(c, data_src1, date_28) for c in code]
data_stock_daliy28_1 = pd.concat(stock_day28_1, axis=0)

stock_day28_2 = [day28(c, data_src2, date_28) for c in code]
data_stock_daliy28_2 = pd.concat(stock_day28_2, axis=0)

data_stock_daliy28_1.to_csv('G:\midasr_data\First_data\data_stock_daliy28_1.csv')
data_stock_daliy28_2.to_csv('G:\midasr_data\First_data\data_stock_daliy28_2.csv') 

# 股票数据：周度数据,频率倍差为12
def weekly_stock(c,data): # c=code data=data_src1/data_src2 
    day = []
    start = []
    end = []
    df = data[data['证券代码'] == c]
    for i in range(1,len(df)-1):
        data_i = df.iloc[i]
        data_i1 = df.iloc[i-1]
        data_i2 = df.iloc[i+1]
        if (not np.isnan(data_i['日收盘价'])) and (np.isnan(data_i1['日收盘价'])):
            # 当前日收盘价非空，但前一个日收盘价为空，记录本周开盘价和开盘日
            day.append(data_i['日期'])
            start.append(data_i['日收盘价'])
            end.append(np.nan)
        if (not np.isnan(data_i['日收盘价'])) and (np.isnan(data_i2['日收盘价'])):
            # 当前日收盘价非空，但后一个日收盘价为空，记录本周收盘价和收盘日
            day.append(data_i['日期'])
            start.append(np.nan)
            end.append(data_i['日收盘价'])
    weekly_dict = { '日期':day,
                  '开盘价':start,
                  '收盘价':end}
    weekly_df = pd.DataFrame(weekly_dict)  
    df_list = weekly_df.values.tolist()
    # 将df_list每2个一组，并计算一组中第一个和第二个数的变化比例
    result = [(df_list[i+1][2] - df_list[i][1]) / df_list[i][1] for i in range(0, len(df_list), 2)]
    day_result = [df_list[i+1][0] for i in range(0, len(df_list), 2)]
    # 将结果转换回dataframe
    week_dict = { '日期':day_result,
                  '周涨幅':result}
    weekly_df= pd.DataFrame(week_dict)
    weekly_stock_df = pd.merge(weekly_df,df,on = ['日期'],how = 'left')
    weekly_stock_df = weekly_stock_df.reindex(columns=['证券代码', '日期', '周涨幅'])
    return weekly_stock_df


# {'000916', '832662'} 这两个因不明原因丢失了
stock_week = [weekly_stock(c, data_src2) for c  in code]
data_stock_weekly = pd.concat(stock_week, axis=0)

data_stock_weekly.to_csv('G:\midasr_data\First_data\data_stock_weekly.csv')


def split_y_m_d(df):
    df['年'] = df['日期'].map(lambda x:x[0:4])
    df['月'] = df['日期'].map(lambda x:x.split('-')[1])
    df['日'] = df['日期'].map(lambda x:x.split('-')[2])
    df['季度'] = [0 for i in range(len(df))]
    return df
# 获取每季度前12个周
stock_weekly_df = split_y_m_d(data_stock_weekly)

def week12(c,data): # c = code data = stock_weekly_df
    df = data[data['证券代码']==c]
    for i in range(len(df)):
        this_month = df['月'][i]
        if this_month in ['01','02','03']: 
            sea = 1
        elif this_month in ['04','05','06']: 
            sea = 2
        elif this_month in ['07','08','09']: 
            sea = 3
        else:
            sea = 4
        df['季度'][i] = sea
    count = 0
    drop_index = []
    for i in range(len(df)-1):
        signal = False
        count += 1
        if count > 12:
            drop_index.append(i)
        if df['季度'][i] != df['季度'][i+1]:
            if count < 12:
                signal = True
                new_row = df.loc[i, :]
                df_before = df.loc[:i,:]
                df_before.loc[i+1] = new_row
                df_next = df.loc[i+1:, :]
                df_new = pd.concat([df_before,df_next], ignore_index=True)
            count = 0 
    if signal:
        df = df_new.drop(drop_index)
    else:
        df = df.drop(drop_index)
    df = df.reset_index()
    return df[['证券代码','日期','周涨幅']]

code2 = list(set(stock_weekly_df['证券代码']))
stock_week12 = [week12(c, stock_weekly_df) for c  in code2]
data_stock_week12 = pd.concat(stock_week12, axis=0)
data_stock_week12.to_csv('G:\midasr_data\First_data\data_stock_week12.csv')
print('Completed!')
```