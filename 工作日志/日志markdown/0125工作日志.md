使用MLPRegressor神经网络回归，代码参考链接：[python MLPRegressor神经网络回归预测](https://blog.csdn.net/xspyzm/article/details/102840768)
1. 采用测试集20%，训练集80%的比例构建模型。
2. 第一个隐藏层有100个节点，第二层有50个，激活函数用identity，权重优化求解器用lbfgs，惩罚系数为0.01，最大迭代次数为200。

激活函数选用identity参考官方MLPRegressor文档:
>'identity': 无操作激活，有助于实现线性瓶颈

权重优化求解器选用bfgs参考官方MLPRegressor文档:
>在训练时间和验证分数方面的大型数据集(具有数千个训练样本或更多),默认解算器'adam'相对来说很好。然而，对于小型数据集，“lbfgs”可以更快地收敛并表现得更好。

选用一支股票的盈收变化值与0~30个滞后期的股票涨跌幅。
以下为1支股票代码测试结果：
```python
Train ERROR =  0.00010622443670919115
Test ERROR =  0.0004179966862039793
```
![[Figure_2.png]]

附测试完整代码
```python
# -*- coding: utf-8 -*-
"""
Created on Wed Jan 25 21:55:19 2023

@author: jc
"""

'''载入数据'''
import pandas as pd
data = pd.read_csv('G:\\Data\\midar_data\\src_data\\Result_0_30.csv')
data_test = data[data['Stkcd']==1]
data_test['changerate'] = data_test['Erana'].diff() # 取盈余差分
data_test = data_test.dropna(axis=0, how='any') # 去除含NA的行
data_test = data_test[data_test.changerate != 0] # 去除changerate为0的行
y,x = data_test['changerate'],data_test.iloc[:,6:]       
'''引入标准化函数'''
from sklearn import preprocessing
x_MinMax = preprocessing.MinMaxScaler() # 通过将每个特征缩放到给定范围来转换特征。
y_MinMax = preprocessing.MinMaxScaler()
 
''' 将 y 转换成 列 '''
import numpy as np
y = np.array(y).reshape(len(y),1)
'''标准化'''
x = x_MinMax.fit_transform(x)
y = y_MinMax.fit_transform(y)
 
''' 按二八原则划分训练集和测试集 '''
from sklearn.model_selection import train_test_split
np.random.seed(2023)
x_train, x_test, y_train, y_test = train_test_split(x,y,test_size = 0.2)
 
'''模型构建'''
from sklearn.neural_network import MLPRegressor
fit1 = MLPRegressor(
        hidden_layer_sizes=(100,50), 
        activation='identity',
        solver='lbfgs',alpha=0.01,max_iter=200)
'''第一个隐藏层有100个节点，第二层有50个，激活函数用identity，梯度下降方法用lbfgs'''        
'''惩罚系数为0.01，最大迭代次数为200'''
print ("fitting model right now")
fit1.fit(x_train,y_train)
pred1_train = fit1.predict(x_train)
'''计算训练集 MSE'''
from sklearn.metrics import mean_squared_error
mse_1 = mean_squared_error(pred1_train,y_train)
print ("Train ERROR = ", mse_1)
'''计算测试集mse'''
pred1_test = fit1.predict(x_test)
mse_2 = mean_squared_error(pred1_test,y_test)
print ("Test ERROR = ", mse_2)
 
'''结果可视化'''
import matplotlib.pyplot as plt
xx=range(0,len(y_test))
plt.figure(figsize=(8,6))
plt.scatter(xx,y_test,color="red",label="Sample Point",linewidth=3) 
plt.plot(xx,pred1_test,color="orange",label="Fitting Line",linewidth=2)
plt.legend()
plt.show()
```