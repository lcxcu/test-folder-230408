### 测试财报滞后期加长

```R
library(midasr)
library(readxl)
library(openxlsx)
# 1 数据录入
## 使用 read_excel() 函数读取 Excel 文件，并使用 select() 函数选择你想要的列
wb <- xlsx::createWorkbook()
sheet <- xlsx::createSheet(wb,sheetName = "newSheet1")
high <- read.csv("G:\\Data\\midar_data\\src_data\\Fin_Daily_all.csv",sep=',' ,encoding='UTF-8')
low <- read.csv("G:\\Data\\midar_data\\src_data\\Fin_Quarter_all.csv",
sep=',' ,encoding='UTF-8')
## 使用 unique()函数对证券代码列进行去重
stock_code <- unique(high$Stkcd) 
```

```R
code <- 600567
## 或600684
## 不同证券代码对应的每日股票收益率（ChangRatio）
##（共7676行,7470行取每月90天83季度）
x_row <- which(high$Stkcd == code)
x1g <-high[x_row[1]:x_row[length(x_row)],'ChangeRatio'] 
x1g <- unlist(x1g,use.names = FALSE)
nx1 <-x1g[1:7470] 
## 不同证券代码对应的财报数据 （83个季度）
y1g <- subset(low, Stkcd==code, select=c('Erana'))
ny1 <-ts(y1g,frequency = 4,start = c(2002,1))
ny1 <-diff(ny1)
## 训练集（模型拟合）取56季度（14年）
xx <- nx1[1:5040]
yy <- ny1[1:56]
# 导入响应包
library(Boruta)
# 创建矩阵
lag <- length(yy)
data_col <- c("yy",paste0("yy.", 1:lag, "/m"))
data <- matrix(yy, nrow = length(yy)+1, ncol = length(data_col), byrow = FALSE)
colnames(data) <- data_col
for (i in 0:length(yy)) {
lag_c <- ifelse(is.na(mls(yy,i,1)), 0, mls(yy,i,1))
    data[ ,i+1] <- lag_c[0:length(data_col)]
 } 
data <- data.frame(data)
boruta <- Boruta(yy ~ ., data = data, doTrace = 2, maxRuns = 500)
print(boruta)
```
以“600567”股票为例测试结果为：
```R
Boruta performed 268 iterations in 5.225067 secs.
 8 attributes confirmed important: yy.1.m, yy.12.m, yy.16.m,
yy.20.m, yy.24.m and 3 more;
 48 attributes confirmed unimportant: yy.10.m, yy.11.m,
yy.13.m, yy.14.m, yy.15.m and 43 more;
```

### 数据库连接代码，还在完善
```python
import pandas as pd

#读取数据集
comp_names = pd.read_csv('compustat_csv_short/2bwzvps2urdxldv2.csv')
#过滤数据集，只包括tic为“DELL”，“IBM”，“MSFT”，“F”，“DIS”的观测值
compcusip = comp_names[comp_names['tic'].isin(["DELL","IBM","MSFT","F","DIS"])]
#通过提取cusip的前8个字符来创建一个新变量cusip8
compcusip['cusip8'] = compcusip['cusip'].str[:8]
#读取数据集
crsp_stocknames = pd.read_csv("CRSP_csv_short/totjakegbgzlkme9.csv")
#按cusip对数据进行排序并删除重复项
crspcusip = crsp_stocknames.sort_values("CUSIP").drop_duplicates(subset=["CUSIP"])
#只选择cusip、permco和permno列
crspcusip = crspcusip[["CUSIP","PERMCO","PERMNO"]]
# 合并cusip8和cusip上的两个数据帧
total = pd.merge(compcusip,crspcusip, left_on='cusip8', right_on='CUSIP', how='inner')

# 定义gvkey
glist = ['006066', '012141', '014489']
# 定义日期范围
fyear1 = 1997
fyear2 = 2006
# Define the selected data items
vars = ['gvkey', 'fyr', 'fyear', 'datadate', 'SALE',
        'AT', 'INDFMT', 'DATAFMT', 'POPSRC', 'CONSOL']
```

