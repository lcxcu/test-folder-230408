### 1. 仔细阅读了《基于供应链关系的股票收益预测研究》，读了一半但还没读完。
### 2. （代码真的写的很慢,需要练习）将数据去重后写入表中，如下： 
 ![image-20221020001729953](C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20221020001729953.png)



```
import xlrd
import xlwt
import difflib


# global firm names 和 us names 的 Global Company Key 和 Company Name 提取
global_workbk = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'+
                                  '\Database Table\global firm names.xlsx')
global_worksh = global_workbk.sheet_by_name('0x77igavdumz8vul')
global_cpnames = global_worksh.col_values(colx = 7, start_rowx = 1)
global_cpkey = global_worksh.col_values(colx = 0, start_rowx = 1)
# 组成列表
global_namekey = list(zip(global_cpnames, global_cpkey))


us_workbk = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'
                              +'\Database Table\\us names.xlsx')
us_worksh = us_workbk .sheet_by_name('76aqys7wh9axjpme')
us_cpnames = us_worksh.col_values(colx = 9, start_rowx = 1)
us_cpkey = us_worksh.col_values(colx = 0, start_rowx = 1)
# 组成列表
us_namekey = list(zip(us_cpnames,us_cpkey))


# 将customer表中的Customer Name列和Global Company Key 提取出
customer_workbk = xlrd.open_workbook(r'C:\Users\jc\Documents\Pydata'+
                                     '\Database Table\customer.xlsx') 
customer_worksh = customer_workbk.sheet_by_name('vozkv0ioajsw5wov')
customer_downstream = customer_worksh.col_values(colx = 2, start_rowx = 1)
customer_upkey = customer_worksh.col_values(colx = 0, start_rowx = 1)
# 组成列表
customer_up_down = list(zip(customer_upkey,customer_downstream))


# global firm names 和 us names 的Global Company Key 和 Company Name列表合并后去重
Allnamekey_lst = list(set( global_namekey+us_namekey))
#对customer_up_down列表也去重
customer_up_down = list(set(customer_up_down))
#按照Global Company Key进行排序
Allnamekey_lst.sort(key=lambda x:x[1])

# 将Global Company Key 和 Company Name 写入Allcompany表中
Allcompany = xlwt.Workbook()
Allcompany_sheet = Allcompany.add_sheet('sheet1')
name_list = ['Global Company Key','Company Name(upstream)','Downstream']
for i in name_list:
    Allcompany_sheet.write(0, name_list.index(i), i)

for namekey in Allnamekey_lst:
    Allcompany_sheet.write(Allnamekey_lst.index(namekey)+1,0,namekey[1])
    Allcompany_sheet.write(Allnamekey_lst.index(namekey)+1,1,namekey[0])
    
cust_num = [[i[1],0] for i in Allnamekey_lst]
#比较 upstream key(customer_up_down[i][0])和global company key(Allnamekey_lst[j][1])
for upkey_down in customer_up_down:
    for name_key in Allnamekey_lst:
        if upkey_down[0] == name_key[1]:
            Allcompany_sheet.write(Allnamekey_lst.index(name_key)+1
                                   ,2+cust_num[Allnamekey_lst.index(name_key)][1]
                                   ,upkey_down[1])
            cust_num[Allnamekey_lst.index(name_key)][1] += 1

# 保存文件
Allcompany.save('Allcompany.xlsx')

```

### 3. 将BM算法以python语言实现,还在测试阶段

pattern模式串是小串，target目标串是大串。
以下代码可以实现查找小串在大串中的位置，如果没有，则返回-1，如果找到了，返回小串的位置：

   ```
   import xlrd
   import xlwt
   # pattern模式串是小串，target目标串是大串。
   #以下代码可以实现查找小串在大串中的位置，如果没有，则返回-1，如果找到了，返回小串的位置
   def pattern(pattern,target):
       patter = pattern.lower()
       target = target.lower()
       tLen = len(target)
       pLen = len(pattern)
       # 当模式串比主串长时，没有可比性，直接返回-1
       if ( pLen > tLen ):
           return -1
       
       bad_table = build_bad_table(pattern)
       good_table = build_good_table(pattern)
      
       for i in range(pLen-1,tLen):
           j = pLen-1
           while(target[i] == pattern[j]):
               if (j ==0):
                   return i
               i -= 1
               j -= 1
           i += max(good_table[pLen-j-1],bad_table[ord(target[i])])
       return -1
   
   def build_bad_table(pattern):
       patter = pattern.lower()
       TABLE_SIZE = 256
       bad_table = ['0' for i in range(TABLE_SIZE)]
       pLen = len(pattern)
       
       for i in range(len(bad_table)):
           bad_table[i] = pLen
           
       for i in range((pLen)-1):
           k = ord(pattern[i])# 记录下当前字符的ASCII码值
           bad_table[k] = pLen-1-i
       
       return bad_table
       
   def build_good_table(pattern):
       patter = pattern.lower()
       pLen = len(pattern)
       lastPrefixPosition = pLen
       good_table = [0 for i in range(pLen)]
       for i in range(pLen-1 , 0 , -1):
           if(isPrefix(pattern, i+1)):
               lastPrefixPosition = i+1
           good_table[pLen-1-i] = lastPrefixPosition-i+pLen-1
           
       for i in range(pLen-1):
           slen = suffixLength(pattern,i)
           good_table[slen] = pLen -1 -i +slen
       
       return good_table
   
   def isPrefix(pattern, p):
       patter = pattern.lower()
       patternLength = len(pattern)
       j = 0
       for i in range(patternLength):
           if(pattern[i] != pattern[j]):
               return False
       return True
   
   def suffixLength(pattern, p):
       pLen = len(pattern)
       length = 0
       i = p
       j = pLen -1
       while((i>=0)&(pattern[i]==pattern[j])):
           length += 1
           i -= 1
           j -= 1
       
       return length
   
   x = pattern('other','FARMER BROTHERS CO')
   print(x)
   ```

   ```
   >>> pattern('other','FARMER BROTHERS CO')
    9 
   ```

   以上算法实现了**字符串位置的查找**，应该是可以用于本实验中**大部分公司名和缩写字符串的匹配的**。
